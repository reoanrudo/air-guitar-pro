<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Test - PC</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      padding: 20px;
      max-width: 600px;
      margin: 0 auto;
    }
    #status {
      padding: 10px;
      background: #f0f0f0;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    #touch-display {
      width: 100%;
      height: 300px;
      border: 2px solid #333;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      position: relative;
    }
    .touch-point {
      width: 20px;
      height: 20px;
      background: red;
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      animation: fade 1s forwards;
    }
    @keyframes fade {
      to { opacity: 0; transform: translate(-50%, -50%) scale(2); }
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      background: #007AFF;
      color: white;
      border: none;
      border-radius: 8px;
      margin: 5px;
    }
    button:disabled {
      background: #ccc;
    }
    #peer-id-display {
      font-size: 18px;
      color: #007AFF;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ğŸ“±â†”ï¸ğŸ’» WebRTC ã‚¿ãƒƒãƒä¸­ç¶™</h1>

  <div id="status">
    <div>ã‚ãªãŸã®ID: <span id="peer-id-display">æ¥ç¶šä¸­...</span></div>
    <div>çŠ¶æ…‹: <span id="connection-status">å¾…æ©Ÿä¸­</span></div>
  </div>

  <div>
    <input type="text" id="remote-peer-id" placeholder="ç›¸æ‰‹ã®IDã‚’å…¥åŠ›" style="padding: 10px; width: 200px;">
    <button id="connect-btn">æ¥ç¶š</button>
  </div>

  <h2>ã‚¿ãƒƒãƒè¡¨ç¤º</h2>
  <div id="touch-display">
    <span>ã‚¿ãƒƒãƒã‚’å¾…ã£ã¦ã„ã¾ã™...</span>
  </div>

  <h2>ãƒ­ã‚°</h2>
  <div id="log" style="background: #f9f9f9; padding: 10px; height: 150px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>

  <script>
    // è¨­å®š
    const SIGNALING_URL = 'ws://localhost:3001';

    // çŠ¶æ…‹
    let ws = null;
    let peerConnection = null;
    let dataChannel = null;
    let myPeerId = null;

    const config = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    // ãƒ­ã‚°å‡ºåŠ›
    function log(msg) {
      const logDiv = document.getElementById('log');
      logDiv.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(msg);
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
    function updateStatus(status) {
      document.getElementById('connection-status').textContent = status;
    }

    // ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š
    function connectToSignaling() {
      ws = new WebSocket(SIGNALING_URL);

      ws.onopen = () => {
        log('âœ… ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š');
      };

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);

        if (message.type === 'id') {
          myPeerId = message.id;
          document.getElementById('peer-id-display').textContent = myPeerId;
          log(`ğŸ“› è‡ªåˆ†ã®ID: ${myPeerId}`);
        }
        else if (message.type === 'offer') {
          log('ğŸ“¥ Offerå—ä¿¡ - ç›¸æ‰‹ã‹ã‚‰æ¥ç¶šã•ã‚Œã¾ã—ãŸ');
          await handleOffer(message);
        }
        else if (message.type === 'answer') {
          log('ğŸ“¥ Answerå—ä¿¡');
          await handleAnswer(message);
        }
        else if (message.type === 'ice-candidate') {
          log('ğŸ“¥ ICE Candidateå—ä¿¡');
          await handleIceCandidate(message);
        }
      };

      ws.onclose = () => {
        log('âŒ ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã‚µãƒ¼ãƒãƒ¼åˆ‡æ–­');
        updateStatus('åˆ‡æ–­');
      };

      ws.onerror = (error) => {
        log('âŒ WebSocketã‚¨ãƒ©ãƒ¼');
        console.error(error);
      };
    }

    // WebRTCæ¥ç¶šã‚’é–‹å§‹ï¼ˆç™ºä¿¡å´ï¼‰
    async function startConnection(remotePeerId) {
      log(`ğŸš€ ${remotePeerId} ã«æ¥ç¶šé–‹å§‹...`);

      peerConnection = new RTCPeerConnection(config);

      // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«ä½œæˆï¼ˆã‚¿ãƒƒãƒãƒ‡ãƒ¼ã‚¿ç”¨ï¼‰
      dataChannel = peerConnection.createDataChannel('touch', {
        ordered: false // é…å»¶ã‚’æœ€å°ã«
      });

      setupDataChannel(dataChannel);

      // ICE candidateåé›†
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          log('ğŸ“¤ ICE Candidateé€ä¿¡');
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            targetId: remotePeerId,
            candidate: event.candidate
          }));
        }
      };

      peerConnection.onconnectionstatechange = () => {
        log(`ğŸ“¡ æ¥ç¶šçŠ¶æ…‹: ${peerConnection.connectionState}`);
        updateStatus(peerConnection.connectionState);
      };

      // Offerä½œæˆ
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      log('ğŸ“¤ Offeré€ä¿¡');
      ws.send(JSON.stringify({
        type: 'offer',
        targetId: remotePeerId,
        offer: offer
      }));
    }

    // Offerå—ä¿¡æ™‚ã®å‡¦ç†ï¼ˆç€ä¿¡å´ï¼‰
    async function handleOffer(message) {
      peerConnection = new RTCPeerConnection(config);

      // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«å—ä¿¡
      peerConnection.ondatachannel = (event) => {
        log('ğŸ“¡ ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«å—ä¿¡');
        setupDataChannel(event.channel);
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          log('ğŸ“¤ ICE Candidateé€ä¿¡');
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            targetId: message.senderId,
            candidate: event.candidate
          }));
        }
      };

      peerConnection.onconnectionstatechange = () => {
        log(`ğŸ“¡ æ¥ç¶šçŠ¶æ…‹: ${peerConnection.connectionState}`);
        updateStatus(peerConnection.connectionState);
      };

      await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      log('ğŸ“¤ Answeré€ä¿¡');
      ws.send(JSON.stringify({
        type: 'answer',
        targetId: message.senderId,
        answer: answer
      }));
    }

    // Answerå—ä¿¡æ™‚ã®å‡¦ç†
    async function handleAnswer(message) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
    }

    // ICE Candidateå—ä¿¡æ™‚ã®å‡¦ç†
    async function handleIceCandidate(message) {
      if (peerConnection) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
      }
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«ã®è¨­å®š
    function setupDataChannel(channel) {
      channel.onopen = () => {
        log('ğŸ‰ ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«æ¥ç¶šï¼ã‚¿ãƒƒãƒã‚’é€ã‚Œã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸ');
        updateStatus('æ¥ç¶šæ¸ˆã¿ - ã‚¿ãƒƒãƒé€ä¿¡å¯èƒ½');
      };

      channel.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'touch') {
          showTouch(data.x, data.y);
          log(`ğŸ‘† ã‚¿ãƒƒãƒå—ä¿¡: x=${data.x}, y=${data.y}`);
        }
      };

      channel.onclose = () => {
        log('âŒ ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ãƒãƒ«åˆ‡æ–­');
        updateStatus('åˆ‡æ–­');
      };
    }

    // ã‚¿ãƒƒãƒè¡¨ç¤º
    function showTouch(x, y) {
      const display = document.getElementById('touch-display');

      // ã‚¿ãƒƒãƒãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆ
      const point = document.createElement('div');
      point.className = 'touch-point';
      point.style.left = x + '%';
      point.style.top = y + '%';

      display.appendChild(point);

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«å‰Šé™¤
      setTimeout(() => point.remove(), 1000);
    }

    // æ¥ç¶šãƒœã‚¿ãƒ³
    document.getElementById('connect-btn').addEventListener('click', () => {
      const remoteId = document.getElementById('remote-peer-id').value.trim();
      if (remoteId) {
        startConnection(remoteId);
      }
    });

    // åˆæœŸåŒ–
    connectToSignaling();
    log('ğŸš€ åˆæœŸåŒ–å®Œäº† - ç›¸æ‰‹ã®IDã‚’å…¥åŠ›ã—ã¦æ¥ç¶šãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„');
  </script>
</body>
</html>
